# AGENT.md
**AI Coding Agent 统一编码纲领（Code & Design Guidelines）**

> 本文档是所有 AI 代码代理（Agent）在本项目中生成代码时必须严格遵循的核心规范。  
> 所有代码必须符合：**模块化、可扩展、可测试、可维护、统一风格**。

---

# 1. 总体原则（General Principles）

1. **严格遵循 SOLID 原则**  
   - **S**：Single Responsibility（单一职责）  
   - **O**：Open/Closed（开闭原则）  
   - **L**：Liskov Substitution（里氏替换）  
   - **I**：Interface Segregation（接口隔离）  
   - **D**：Dependency Inversion（依赖倒置）

2. 任何代码都必须语义清晰、分层明确、可测试性强。  
3. 模块必须支持扩展，而不是改写已有代码。  
4. 禁止输出一次性、不可维护的「拼装代码」。  
5. 对于与 UI 交互相关的**局部功能或模块**，**推荐**采用 MVVM 拆分为：Model（数据） + ViewModel（状态与业务逻辑）+ View（UI 渲染），以提升可维护性和可测试性。  
6. 在**宏观架构**上按领域或业务边界划分模块，通过稳定接口协作，避免跨模块直接访问内部实现，从而降低耦合度、提升可演进性。  
7. 所有教学案例 / 练习题 / 业务场景等内容必须是**数据驱动（data‑driven）**的：从配置、JSON、数据库或 API 等数据源加载，不得将案例内容（题目、文案、选项、答案等）直接硬编码在前端或后端代码中。

---

# 2. 架构要求（Architecture Requirements）

## 2.1 分层结构（Model–View–ViewModel）

> 以下 MVVM 分层规范是针对**局部 UI 功能模块的推荐架构**，用于组织与界面交互直接相关的代码；对于纯领域或基础设施模块，可根据实际情况选择合适的分层方式，但仍需保持高内聚、低耦合。

### **Model（核心数据 & 业务实体）**
- 只包含：数据结构、业务实体、基本方法（纯逻辑）。  
- 不包含 UI 逻辑、状态管理。  
- 可序列化、可单元测试。  
- 必须与 View、ViewModel 完全解耦。

---

### **ViewModel（状态管理 & 业务逻辑层）**
作为 MVVM 的核心：

- 负责处理所有业务逻辑、状态变化、服务调用。  
- 暴露给 View 的是「可绑定状态 + 事件方法」。  
- 不包含 DOM 相关操作。  
- 不依赖具体 UI 组件，只依赖 Model。  
- 必须可单元测试。  
- 必须保持「可观察状态」（例如使用 React 的状态或外部状态管理器）。

**禁止：**  
- 在 View 中写业务逻辑。  
- 在 Model 中写交互逻辑。  
- 在 ViewModel 中直接操作 DOM。

---

### **View（展示层）**
- 只负责 UI 渲染与交互触发。  
- 所有复杂逻辑必须从 View 中抽离。  
- 通过 props 或绑定机制使用 ViewModel。  
- 组件必须可复用、可组合、可替换。  
- 必须为 “pure component”。

**禁止行为：**  
- 在 View 中写网络请求。  
- 在 View 中读写全局状态。  
- 在 View 中进行业务逻辑判断。

---

## 2.2 模块化（Modularity）
- 在宏观架构层面按领域或业务边界拆分为独立模块，每个模块职责单一、边界清晰。  
- 每个模块对外只暴露清晰、稳定的 public API。  
- 模块之间依赖必须通过接口或抽象层，而不是直接依赖具体实现，并尽量保持单向依赖。  
- 严格避免循环依赖和隐式耦合，禁止跨模块直接访问彼此内部实现。  
- View 层绝不能跨模块访问其他模块的 Model，只能通过模块暴露的接口或对应的 ViewModel 进行交互。

---

## 2.3 可测试性（Testability）
- Model 必须具备完整单元测试。  
- ViewModel 必须可在无 UI 环境中测试。  
- View（React 组件）使用 React Testing Library。  
- 禁止不可测试的隐藏逻辑（如直接操作全局对象）。

---

# 3. UI 设计规范（UI Development Guidelines）

## 3.1 布局
- **强制使用 flex layout。**  
- 禁止使用 `position: absolute` 作为常规布局方式。  
- 推荐使用 gap、align、justify 等现代 flex 属性。

---

## 3.2 样式规范
- 必须使用 `className`。  
- 样式写在 CSS/SCSS 文件中。  
- 禁止 inline style（禁止使用 `style={{}}`）。

---

## 3.3 组件要求
所有组件必须：

- 可复用。  
- 可组合。  
- 无副作用（pure）。  
- 通过 props 获取所有外部信息。  
- 不依赖全局变量。  
- 拆分为「容器组件 + 展示组件」。  
- 容器组件：仅与 ViewModel 交互。  
- 展示组件：只渲染 UI，不包含业务逻辑。

---

## 3.4 用户交互规范
- UI 只触发事件。  
- ViewModel 处理事件逻辑。  
- 永远不要在 View 中：  
  - 发起 HTTP 请求。  
  - 操作 localStorage。  
  - 进行复杂业务逻辑判断。  
  - 管理状态。

---

# 4. 代码风格（Code Style Requirements）

## 4.1 TypeScript 强制要求
必须开启：

```json
{
  "strict": true,
  "noImplicitAny": true,
  "strictNullChecks": true
}
```

---

## 4.2 命名规范

- 变量使用 `camelCase`。  
- 类使用 `PascalCase`。  
- 常量使用 `UPPER_SNAKE_CASE`。  
- 文件名使用 `camelCase`。

---

## 4.3 禁止魔法数字

- 所有数值和字符串常量必须提取到常量或配置文件中。

---

## 4.4 文件长度限制

- 单个文件超过 **500 行** 必须拆分。  
- 单个函数超过 **300 行** 必须拆分。

---

# 5. 文档与注释（Documentation Guidelines）

所有模块必须包含：

1. 文件头部注释（说明模块用途）。  
2. 函数注释（参数、返回值、异常）。  
3. 至少一个 usage example（使用示例），示例本身也应尽量体现数据驱动的设计方式，而不是演示硬编码常量。

---

# 6. 行为要求（Agent Behavior Requirements）

AI（Agent）在生成代码时必须遵守：

## 6.1 输出高质量代码，而不是最短代码

- 首要目标是：**可维护、可扩展、可测试**。

## 6.2 所有输出必须具备

- 可扩展。  
- 可测试。  
- 可读。  
- 可维护。  
- 符合 SOLID。  
- 采用清晰的分层架构（对于界面相关的局部模块优先考虑 MVVM，并遵守其分层约束）。  
- 不使用 inline style。  
- 组件可复用、可组合。  
- 业务案例、题库、教学内容等通过数据驱动实现，而非写死在代码中。

## 6.3 禁止行为

- 一次性拼凑代码。  
- 在 View 中写业务逻辑。  
- 在 ViewModel 中写繁重的数据结构或持久化逻辑。  
- 在 Model 中写 UI 逻辑。  
- 任意写死全局状态。  
- 将教学案例 / 题目 / 选项 / 文案等业务内容硬编码在代码中。  
- 函数过长、职责不清。

## 6.4 推荐行为

- 抽象。  
- 模块化。  
- 明确接口。  
- 单元测试友好。  
- 小函数、小组件、小模块。  
- 通过配置或数据源驱动行为，方便后续扩展和运营。

---

# 7. Prompt 规范（Prompt Standards for Agent）

- AI 必须在输入不明确时主动询问。  
- 如果架构有更优选择，必须提出建议。  
- 每次输出前必须进行自检（self-review）：  
  - 界面相关局部模块是否合理采用并遵守 MVVM？  
  - 是否符合 SOLID？  
  - 是否可测试？  
  - 是否避免视图与业务逻辑耦合？  
  - 是否避免使用 inline style？  
  - 是否将案例与业务文案从代码中抽离为数据驱动？

---

# 8. 目标（Agent Mission）

本规范旨在确保所有 AI 输出的代码：

- 结构清晰。  
- 长期可维护。  
- 具备行业工程化质量。  
- 在局部模块层面能良好适配现代前端 MVVM 等主流分层架构。  
- 在案例与内容层面实现真正的数据驱动，方便配置化与持续迭代。  
- 能为「小墨学习交互系统」提供稳固的基础框架。

**AI 代理的使命是：生成专业、可扩展、可维护、数据驱动的工程代码，而不是简单拼接代码。**

---

